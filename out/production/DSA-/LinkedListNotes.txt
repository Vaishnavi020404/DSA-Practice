
When and Where to use LinkedList and where to use ArrayList:
| **Operation** | **ArrayList** (Time Complexity) | **LinkedList** (Time Complexity) | **Better Option** |
| ------------- | ------------------------------- | -------------------------------- | ----------------- |
| **Insert**    | O(n) (shifting needed)          | O(1) (just pointer change)       | **LinkedList**    |
| **Search**    | O(1) (direct index access)      | O(n) (traverse nodes)            | **ArrayList**     |

Properties of Linked List

âœ… Variable Size â€“ Can grow or shrink dynamically (no fixed size like arrays).

âœ… Non-contiguous Memory â€“ Nodes are stored in scattered memory locations, connected using pointers.

âœ… Fast Insertion â€“ O(1) time (just change pointers, no shifting like arrays).

âœ… Slower Search â€“ O(n) time (must traverse nodes one by one).



head â†’ Node1(data=A,next=Node2)
         â†“
       Node2(data=B,next=Node3)
         â†“
       Node3(data=C,next=null)


--------------------------------------------------------------------------------
ğŸ“š Collection Classes in Java

Collection classes = pre-built data structures in Java

They are part of Java Collections Framework (JCF)

They help you store, organize, and manage data easily.

You donâ€™t have to write your own Node, next, etc.

They come with built-in methods like .add(), .remove(), .size(), .clear().


ğŸ›  Examples of Collection Classes

List (ordered, allows duplicates)

ArrayList â†’ like a resizable array

LinkedList â†’ like your custom linked list but with built-in methods

Set (no duplicates allowed)

HashSet â†’ stores unique items, fast lookup

TreeSet â†’ stores unique items in sorted order

Queue / Deque (FIFO, LIFO structures)

PriorityQueue â†’ queue with priority

ArrayDeque â†’ double-ended queue

Map (key-value pairs)

HashMap â†’ store data as key â†’ value

TreeMap â†’ sorted keys
---------------------------------------------------------------------------------
ğŸ“ Java Collections Framework (JCF) â€” Notes for Interview

Definition: A set of ready-made classes & interfaces in Java to store and manage groups of objects.

Advantage: Saves time (no need to build data structures manually), provides built-in methods like .add(), .remove(), .size().

ğŸŒ³ Main Interfaces

List â†’ ordered, allows duplicates

Implementations: ArrayList, LinkedList, Vector

Set â†’ no duplicates

Implementations: HashSet, LinkedHashSet, TreeSet

Queue â†’ follows FIFO (first in, first out)

Implementations: PriorityQueue, ArrayDeque

Map â†’ key-value pairs (not part of Collection, but in JCF)

Implementations: HashMap, TreeMap, LinkedHashMap

â­ Common Methods

.add(element) â†’ add data

.remove(element) â†’ remove data

.size() â†’ number of elements

.contains(element) â†’ check existence

.clear() â†’ empty the collection

ğŸ”‘ Key Points

List: ordered, duplicates allowed

Set: unique elements only

Queue: processing order

Map: key â†’ value storage

Part of java.util package

âš¡ One-liner for interviews:
â€œJava Collections Framework is a set of classes & interfaces (List, Set, Queue, Map) that provide ready-made data structures with built-in methods to store, retrieve, and process groups of objects efficiently.â€

------------------------------------------------------------------------------

     public static ListNode buildList(String[] parts){
            ListNode head=null, tail=null;
            for(String part:parts){
                ListNode node=new ListNode(Integer.parseInt(part));
                if(head==null) head=tail=node;
                else{
                    tail.next=node;
                    tail=node;
                }
            }
            return head;
        }

"1 2 3"
â†’ ["1", "2", "3"]
â†’ [1] â†’ [2] â†’ [3] â†’ null

--------------------------------------------------------------------------------
