ğŸ”¹ Arrays

Better: Simple, fast, contiguous memory, direct index access in O(1).

Not better: Fixed size, insertion/deletion is costly (O(n)).

ğŸ”¹ Sorting

Better: Brings order â†’ faster searching (binary search), easier data analysis.

Not better: Takes time (O(n log n)), not useful if you only need one quick lookup.

ğŸ”¹ Searching

Linear Search: Works on unsorted data, simple to implement, but slow (O(n)).

Binary Search: Super fast (O(log n)) but needs sorted data.

ğŸ”¹ Strings

Better: Easy handling of text data, tons of built-in methods.

Not better: Immutable in Java â†’ every modification creates a new string (memory + time overhead).




ğŸ”¹ Recursion

Why itâ€™s better

Code clarity & simplicity â€“ Problems like tree traversal, graph DFS, backtracking (e.g., N-Queens, permutations), divide-and-conquer (merge sort, quicksort) are naturally recursive. Writing them recursively makes code short, readable, and maps directly to the problem logic.
ğŸ‘‰ Example: DFS in a tree is just â€œvisit node â†’ recurse on childrenâ€ (much cleaner than managing your own stack).

Breaks down complexity â€“ Converts a big problem into smaller subproblems. This is especially useful in dynamic programming and mathematical problems (factorial, Fibonacci, GCD, etc.).

Why itâ€™s not better

Memory overhead â€“ Every recursive call is pushed onto the call stack. If recursion depth is too high, it risks StackOverflowError.
ğŸ‘‰ Example: Recursive Fibonacci (naÃ¯ve) for large n is terrible.

Performance issues â€“ Sometimes iterative solutions are faster and more memory-efficient.
ğŸ‘‰ Example: Factorial with a simple loop avoids extra function call overhead.

Harder to debug â€“ Deep recursion can be confusing to trace in large projects.

Interview-worthy one-liner:

ğŸ‘‰ â€œRecursion makes problems like trees and divide-and-conquer elegant and clean, but itâ€™s memory-hungry and can be slower than iterative approaches for large inputs.â€

ğŸ”¹ HashMap

Better: Stores keyâ€“value pairs with O(1) average lookup, insert, delete, great for quick data access.

Not better: No ordering, uses more memory than arrays/lists.

ğŸ”¹ HashSet

Better: Stores unique elements only with O(1) operations, perfect for duplicate removal and membership checks.

Not better: No ordering, canâ€™t store duplicates, not useful when you need indexed access.