Reminder(for my self):
150 problem->undertsand hwo to take user input
same for all the problems of linkedlist,stack,queues

| Algorithm      | Best Case  | Worst Case | Average Case | Space Complexity | Stable |
| -------------- | ---------- | ---------- | ------------ | ---------------- | ------ |
| Bubble Sort    | O(n)       | O(n²)      | O(n²)        | O(1)             | Yes    |
| Selection Sort | O(n²)      | O(n²)      | O(n²)        | O(1)             | No     |
| Insertion Sort | O(n)       | O(n²)      | O(n²)        | O(1)             | Yes    |
| Merge Sort     | O(n log n) | O(n log n) | O(n log n)   | O(n)             | Yes    |
| Quick Sort     | O(n log n) | O(n²)      | O(n log n)   | O(log n)         | No     |

⚡ One-Line Triggers (for quick memory)

Bubble → Neighbors swap, biggest goes right each pass.

Insertion → Like arranging cards, put current element in right place.

Selection → Pick smallest, put in front each time.
===========================================================

Bubble Sort recursive = just replace outer loop with recursion.

Insertion Sort recursive = sort first n-1 elements, then insert last element.

Selection Sort recursive = find min, swap, recurse on rest.
=================================================
🔹 Arrays

Better: Simple, fast, contiguous memory, direct index access in O(1).

Not better: Fixed size, insertion/deletion is costly (O(n)).

🔹 Sorting

Better: Brings order → faster searching (binary search), easier data analysis.

Not better: Takes time (O(n log n)), not useful if you only need one quick lookup.

🔹 Searching

Linear Search: Works on unsorted data, simple to implement, but slow (O(n)).

Binary Search: Super fast (O(log n)) but needs sorted data.

🔹 Strings

Better: Easy handling of text data, tons of built-in methods.

Not better: Immutable in Java → every modification creates a new string (memory + time overhead).




🔹 Recursion

Why it’s better

Code clarity & simplicity – Problems like tree traversal, graph DFS, backtracking (e.g., N-Queens, permutations), divide-and-conquer (merge sort, quicksort) are naturally recursive. Writing them recursively makes code short, readable, and maps directly to the problem logic.
👉 Example: DFS in a tree is just “visit node → recurse on children” (much cleaner than managing your own stack).

Breaks down complexity – Converts a big problem into smaller subproblems. This is especially useful in dynamic programming and mathematical problems (factorial, Fibonacci, GCD, etc.).

Why it’s not better

Memory overhead – Every recursive call is pushed onto the call stack. If recursion depth is too high, it risks StackOverflowError.
👉 Example: Recursive Fibonacci (naïve) for large n is terrible.

Performance issues – Sometimes iterative solutions are faster and more memory-efficient.
👉 Example: Factorial with a simple loop avoids extra function call overhead.

Harder to debug – Deep recursion can be confusing to trace in large projects.

Interview-worthy one-liner:

👉 “Recursion makes problems like trees and divide-and-conquer elegant and clean, but it’s memory-hungry and can be slower than iterative approaches for large inputs.”

🔹 HashMap

Better: Stores key–value pairs with O(1) average lookup, insert, delete, great for quick data access.

Not better: No ordering, uses more memory than arrays/lists.

🔹 HashSet

Better: Stores unique elements only with O(1) operations, perfect for duplicate removal and membership checks.

Not better: No ordering, can’t store duplicates, not useful when you need indexed access.

## 📚 Regex & String Cleaning Notes (Java)

**Topic:** Removing non-alphanumeric characters using regex in Java

---

### 1️⃣ `replaceAll()` Method

* **Syntax:**

  ```java
  string.replaceAll(regex, replacement)
  ```
* **Purpose:** Replace all substrings matching the regex with the replacement string.
* **Example:**

  ```java
  s.replaceAll("[^a-zA-Z0-9]", "")
  ```

  → Removes all non-alphanumeric characters from `s`.

---

### 2️⃣ Regex Breakdown: `[^a-zA-Z0-9]`

| Part                  | Meaning                                                    |
| --------------------- | ---------------------------------------------------------- |
| `[]`                  | Character class, matches any one character inside brackets |
| `a-z`                 | Any lowercase letter                                       |
| `A-Z`                 | Any uppercase letter                                       |
| `0-9`                 | Any digit                                                  |
| `^` (inside brackets) | Negates the class → matches anything NOT listed            |

✅ So `[^a-zA-Z0-9]` matches **any character that is not a letter or digit** (spaces, punctuation, symbols, etc.)

---

### 3️⃣ Replacement: `""` (Empty String)

* Replaces matched characters with nothing → effectively **removing them**.
* Ensures the string contains **only letters and digits** after this operation.

---

### 4️⃣ Example Walkthrough

```java
String s = "A man, a plan, a canal: Panama!";
s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
System.out.println(s);
```

**Step by step:**

1. Original: `"A man, a plan, a canal: Panama!"`
2. After `replaceAll("[^a-zA-Z0-9]", "")`: `"AmanaplanacanalPanama"`
3. After `.toLowerCase()`: `"amanaplanacanalpanama"`

✅ Now ready for palindrome or anagram checks.

---

### 5️⃣ Key Takeaways

1. **`StringBuilder` is for building/modifying strings**, **not for searching**.
2. **Searching or checking duplicates** → use **HashSet** or **HashMap**.
3. Regex + `replaceAll` is a **fast, clean way to preprocess strings** for algorithms like palindrome checking.
4. After preprocessing, you can use **two pointers, frequency arrays, or sorting** as needed.

---

### 💡 Exam Tip

* Remember: `[^...]` inside brackets **negates** the set.
* Combining with `.toLowerCase()` gives a **uniform string** for comparison.
* Works for **palindrome, anagram, and other character-only string checks**.

General Rule

Every time you divide by 2, the number of steps = how many times 2 fits into n.
That’s exactly the definition of log base 2 of n (log₂(n)).

✅ So:

Time complexity counts steps → steps = log₂(n) → O(log n).

Space complexity counts function calls waiting → also log₂(n) → O(log n).