Reminder(for my self):
150 problem->undertsand hwo to take user input
same for all the problems of linkedlist,stack,queues

| Algorithm      | Best Case  | Worst Case | Average Case | Space Complexity | Stable |
| -------------- | ---------- | ---------- | ------------ | ---------------- | ------ |
| Bubble Sort    | O(n)       | O(nÂ²)      | O(nÂ²)        | O(1)             | Yes    |
| Selection Sort | O(nÂ²)      | O(nÂ²)      | O(nÂ²)        | O(1)             | No     |
| Insertion Sort | O(n)       | O(nÂ²)      | O(nÂ²)        | O(1)             | Yes    |
| Merge Sort     | O(n log n) | O(n log n) | O(n log n)   | O(n)             | Yes    |
| Quick Sort     | O(n log n) | O(nÂ²)      | O(n log n)   | O(log n)         | No     |

ğŸ”¹ Arrays

Better: Simple, fast, contiguous memory, direct index access in O(1).

Not better: Fixed size, insertion/deletion is costly (O(n)).

ğŸ”¹ Sorting

Better: Brings order â†’ faster searching (binary search), easier data analysis.

Not better: Takes time (O(n log n)), not useful if you only need one quick lookup.

ğŸ”¹ Searching

Linear Search: Works on unsorted data, simple to implement, but slow (O(n)).

Binary Search: Super fast (O(log n)) but needs sorted data.

ğŸ”¹ Strings

Better: Easy handling of text data, tons of built-in methods.

Not better: Immutable in Java â†’ every modification creates a new string (memory + time overhead).




ğŸ”¹ Recursion

Why itâ€™s better

Code clarity & simplicity â€“ Problems like tree traversal, graph DFS, backtracking (e.g., N-Queens, permutations), divide-and-conquer (merge sort, quicksort) are naturally recursive. Writing them recursively makes code short, readable, and maps directly to the problem logic.
ğŸ‘‰ Example: DFS in a tree is just â€œvisit node â†’ recurse on childrenâ€ (much cleaner than managing your own stack).

Breaks down complexity â€“ Converts a big problem into smaller subproblems. This is especially useful in dynamic programming and mathematical problems (factorial, Fibonacci, GCD, etc.).

Why itâ€™s not better

Memory overhead â€“ Every recursive call is pushed onto the call stack. If recursion depth is too high, it risks StackOverflowError.
ğŸ‘‰ Example: Recursive Fibonacci (naÃ¯ve) for large n is terrible.

Performance issues â€“ Sometimes iterative solutions are faster and more memory-efficient.
ğŸ‘‰ Example: Factorial with a simple loop avoids extra function call overhead.

Harder to debug â€“ Deep recursion can be confusing to trace in large projects.

Interview-worthy one-liner:

ğŸ‘‰ â€œRecursion makes problems like trees and divide-and-conquer elegant and clean, but itâ€™s memory-hungry and can be slower than iterative approaches for large inputs.â€

ğŸ”¹ HashMap

Better: Stores keyâ€“value pairs with O(1) average lookup, insert, delete, great for quick data access.

Not better: No ordering, uses more memory than arrays/lists.

ğŸ”¹ HashSet

Better: Stores unique elements only with O(1) operations, perfect for duplicate removal and membership checks.

Not better: No ordering, canâ€™t store duplicates, not useful when you need indexed access.

## ğŸ“š Regex & String Cleaning Notes (Java)

**Topic:** Removing non-alphanumeric characters using regex in Java

---

### 1ï¸âƒ£ `replaceAll()` Method

* **Syntax:**

  ```java
  string.replaceAll(regex, replacement)
  ```
* **Purpose:** Replace all substrings matching the regex with the replacement string.
* **Example:**

  ```java
  s.replaceAll("[^a-zA-Z0-9]", "")
  ```

  â†’ Removes all non-alphanumeric characters from `s`.

---

### 2ï¸âƒ£ Regex Breakdown: `[^a-zA-Z0-9]`

| Part                  | Meaning                                                    |
| --------------------- | ---------------------------------------------------------- |
| `[]`                  | Character class, matches any one character inside brackets |
| `a-z`                 | Any lowercase letter                                       |
| `A-Z`                 | Any uppercase letter                                       |
| `0-9`                 | Any digit                                                  |
| `^` (inside brackets) | Negates the class â†’ matches anything NOT listed            |

âœ… So `[^a-zA-Z0-9]` matches **any character that is not a letter or digit** (spaces, punctuation, symbols, etc.)

---

### 3ï¸âƒ£ Replacement: `""` (Empty String)

* Replaces matched characters with nothing â†’ effectively **removing them**.
* Ensures the string contains **only letters and digits** after this operation.

---

### 4ï¸âƒ£ Example Walkthrough

```java
String s = "A man, a plan, a canal: Panama!";
s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
System.out.println(s);
```

**Step by step:**

1. Original: `"A man, a plan, a canal: Panama!"`
2. After `replaceAll("[^a-zA-Z0-9]", "")`: `"AmanaplanacanalPanama"`
3. After `.toLowerCase()`: `"amanaplanacanalpanama"`

âœ… Now ready for palindrome or anagram checks.

---

### 5ï¸âƒ£ Key Takeaways

1. **`StringBuilder` is for building/modifying strings**, **not for searching**.
2. **Searching or checking duplicates** â†’ use **HashSet** or **HashMap**.
3. Regex + `replaceAll` is a **fast, clean way to preprocess strings** for algorithms like palindrome checking.
4. After preprocessing, you can use **two pointers, frequency arrays, or sorting** as needed.

---

### ğŸ’¡ Exam Tip

* Remember: `[^...]` inside brackets **negates** the set.
* Combining with `.toLowerCase()` gives a **uniform string** for comparison.
* Works for **palindrome, anagram, and other character-only string checks**.

General Rule

Every time you divide by 2, the number of steps = how many times 2 fits into n.
Thatâ€™s exactly the definition of log base 2 of n (logâ‚‚(n)).

âœ… So:

Time complexity counts steps â†’ steps = logâ‚‚(n) â†’ O(log n).

Space complexity counts function calls waiting â†’ also logâ‚‚(n) â†’ O(log n).