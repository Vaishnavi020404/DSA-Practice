When and Where to use LinkedList and where to use ArrayList:
| **Operation** | **ArrayList** (Time Complexity) | **LinkedList** (Time Complexity) | **Better Option** |
| ------------- | ------------------------------- | -------------------------------- | ----------------- |
| **Insert**    | O(n) (shifting needed)          | O(1) (just pointer change)       | **LinkedList**    |
| **Search**    | O(1) (direct index access)      | O(n) (traverse nodes)            | **ArrayList**     |

Properties of Linked List

âœ… Variable Size â€“ Can grow or shrink dynamically (no fixed size like arrays).

âœ… Non-contiguous Memory â€“ Nodes are stored in scattered memory locations, connected using pointers.

âœ… Fast Insertion â€“ O(1) time (just change pointers, no shifting like arrays).

âœ… Slower Search â€“ O(n) time (must traverse nodes one by one).



head â†’ Node1(data=A,next=Node2)
         â†“
       Node2(data=B,next=Node3)
         â†“
       Node3(data=C,next=null)


--------------------------------------------------------------------------------
ğŸ“š Collection Classes in Java

Collection classes = pre-built data structures in Java

They are part of Java Collections Framework (JCF)

They help you store, organize, and manage data easily.

You donâ€™t have to write your own Node, next, etc.

They come with built-in methods like .add(), .remove(), .size(), .clear().


ğŸ›  Examples of Collection Classes

List (ordered, allows duplicates)

ArrayList â†’ like a resizable array

LinkedList â†’ like your custom linked list but with built-in methods

Set (no duplicates allowed)

HashSet â†’ stores unique items, fast lookup

TreeSet â†’ stores unique items in sorted order

Queue / Deque (FIFO, LIFO structures)

PriorityQueue â†’ queue with priority

ArrayDeque â†’ double-ended queue

Map (key-value pairs)

HashMap â†’ store data as key â†’ value

TreeMap â†’ sorted keys
---------------------------------------------------------------------------------
ğŸ“ Java Collections Framework (JCF) â€” Notes for Interview

Definition: A set of ready-made classes & interfaces in Java to store and manage groups of objects.

Advantage: Saves time (no need to build data structures manually), provides built-in methods like .add(), .remove(), .size().

ğŸŒ³ Main Interfaces

List â†’ ordered, allows duplicates

Implementations: ArrayList, LinkedList, Vector

Set â†’ no duplicates

Implementations: HashSet, LinkedHashSet, TreeSet

Queue â†’ follows FIFO (first in, first out)

Implementations: PriorityQueue, ArrayDeque

Map â†’ key-value pairs (not part of Collection, but in JCF)

Implementations: HashMap, TreeMap, LinkedHashMap

â­ Common Methods

.add(element) â†’ add data

.remove(element) â†’ remove data

.size() â†’ number of elements

.contains(element) â†’ check existence

.clear() â†’ empty the collection

ğŸ”‘ Key Points

List: ordered, duplicates allowed

Set: unique elements only

Queue: processing order

Map: key â†’ value storage

Part of java.util package

âš¡ One-liner for interviews:
â€œJava Collections Framework is a set of classes & interfaces (List, Set, Queue, Map) that provide ready-made data structures with built-in methods to store, retrieve, and process groups of objects efficiently.â€

------------------------------------------------------------------------------

     public static ListNode buildList(String[] parts){
            ListNode head=null, tail=null;
            for(String part:parts){
                ListNode node=new ListNode(Integer.parseInt(part));
                if(head==null) head=tail=node;
                else{
                    tail.next=node;
                    tail=node;
                }
            }
            return head;
        }

"1 2 3"
â†’ ["1", "2", "3"]
â†’ [1] â†’ [2] â†’ [3] â†’ null

--------------------------------------------------------------------------------



## ğŸ“š Regex & String Cleaning Notes (Java)

**Topic:** Removing non-alphanumeric characters using regex in Java

---

### 1ï¸âƒ£ `replaceAll()` Method

* **Syntax:**

  ```java
  string.replaceAll(regex, replacement)
  ```
* **Purpose:** Replace all substrings matching the regex with the replacement string.
* **Example:**

  ```java
  s.replaceAll("[^a-zA-Z0-9]", "")
  ```

  â†’ Removes all non-alphanumeric characters from `s`.

---

### 2ï¸âƒ£ Regex Breakdown: `[^a-zA-Z0-9]`

| Part                  | Meaning                                                    |
| --------------------- | ---------------------------------------------------------- |
| `[]`                  | Character class, matches any one character inside brackets |
| `a-z`                 | Any lowercase letter                                       |
| `A-Z`                 | Any uppercase letter                                       |
| `0-9`                 | Any digit                                                  |
| `^` (inside brackets) | Negates the class â†’ matches anything NOT listed            |

âœ… So `[^a-zA-Z0-9]` matches **any character that is not a letter or digit** (spaces, punctuation, symbols, etc.)

---

### 3ï¸âƒ£ Replacement: `""` (Empty String)

* Replaces matched characters with nothing â†’ effectively **removing them**.
* Ensures the string contains **only letters and digits** after this operation.

---

### 4ï¸âƒ£ Example Walkthrough

```java
String s = "A man, a plan, a canal: Panama!";
s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
System.out.println(s);
```

**Step by step:**

1. Original: `"A man, a plan, a canal: Panama!"`
2. After `replaceAll("[^a-zA-Z0-9]", "")`: `"AmanaplanacanalPanama"`
3. After `.toLowerCase()`: `"amanaplanacanalpanama"`

âœ… Now ready for palindrome or anagram checks.

---

### 5ï¸âƒ£ Key Takeaways

1. **`StringBuilder` is for building/modifying strings**, **not for searching**.
2. **Searching or checking duplicates** â†’ use **HashSet** or **HashMap**.
3. Regex + `replaceAll` is a **fast, clean way to preprocess strings** for algorithms like palindrome checking.
4. After preprocessing, you can use **two pointers, frequency arrays, or sorting** as needed.

---

### ğŸ’¡ Exam Tip

* Remember: `[^...]` inside brackets **negates** the set.
* Combining with `.toLowerCase()` gives a **uniform string** for comparison.
* Works for **palindrome, anagram, and other character-only string checks**.

General Rule

Every time you divide by 2, the number of steps = how many times 2 fits into n.
Thatâ€™s exactly the definition of log base 2 of n (logâ‚‚(n)).

âœ… So:

Time complexity counts steps â†’ steps = logâ‚‚(n) â†’ O(log n).

Space complexity counts function calls waiting â†’ also logâ‚‚(n) â†’ O(log n).