When and Where to use LinkedList and where to use ArrayList:
| **Operation** | **ArrayList** (Time Complexity) | **LinkedList** (Time Complexity) | **Better Option** |
| ------------- | ------------------------------- | -------------------------------- | ----------------- |
| **Insert**    | O(n) (shifting needed)          | O(1) (just pointer change)       | **LinkedList**    |
| **Search**    | O(1) (direct index access)      | O(n) (traverse nodes)            | **ArrayList**     |

Properties of Linked List

✅ Variable Size – Can grow or shrink dynamically (no fixed size like arrays).

✅ Non-contiguous Memory – Nodes are stored in scattered memory locations, connected using pointers.

✅ Fast Insertion – O(1) time (just change pointers, no shifting like arrays).

✅ Slower Search – O(n) time (must traverse nodes one by one).



head → Node1(data=A,next=Node2)
         ↓
       Node2(data=B,next=Node3)
         ↓
       Node3(data=C,next=null)


--------------------------------------------------------------------------------
📚 Collection Classes in Java

Collection classes = pre-built data structures in Java

They are part of Java Collections Framework (JCF)

They help you store, organize, and manage data easily.

You don’t have to write your own Node, next, etc.

They come with built-in methods like .add(), .remove(), .size(), .clear().


🛠 Examples of Collection Classes

List (ordered, allows duplicates)

ArrayList → like a resizable array

LinkedList → like your custom linked list but with built-in methods

Set (no duplicates allowed)

HashSet → stores unique items, fast lookup

TreeSet → stores unique items in sorted order

Queue / Deque (FIFO, LIFO structures)

PriorityQueue → queue with priority

ArrayDeque → double-ended queue

Map (key-value pairs)

HashMap → store data as key → value

TreeMap → sorted keys
---------------------------------------------------------------------------------
📝 Java Collections Framework (JCF) — Notes for Interview

Definition: A set of ready-made classes & interfaces in Java to store and manage groups of objects.

Advantage: Saves time (no need to build data structures manually), provides built-in methods like .add(), .remove(), .size().

🌳 Main Interfaces

List → ordered, allows duplicates

Implementations: ArrayList, LinkedList, Vector

Set → no duplicates

Implementations: HashSet, LinkedHashSet, TreeSet

Queue → follows FIFO (first in, first out)

Implementations: PriorityQueue, ArrayDeque

Map → key-value pairs (not part of Collection, but in JCF)

Implementations: HashMap, TreeMap, LinkedHashMap

⭐ Common Methods

.add(element) → add data

.remove(element) → remove data

.size() → number of elements

.contains(element) → check existence

.clear() → empty the collection

🔑 Key Points

List: ordered, duplicates allowed

Set: unique elements only

Queue: processing order

Map: key → value storage

Part of java.util package

⚡ One-liner for interviews:
“Java Collections Framework is a set of classes & interfaces (List, Set, Queue, Map) that provide ready-made data structures with built-in methods to store, retrieve, and process groups of objects efficiently.”

------------------------------------------------------------------------------

     public static ListNode buildList(String[] parts){
            ListNode head=null, tail=null;
            for(String part:parts){
                ListNode node=new ListNode(Integer.parseInt(part));
                if(head==null) head=tail=node;
                else{
                    tail.next=node;
                    tail=node;
                }
            }
            return head;
        }

"1 2 3"
→ ["1", "2", "3"]
→ [1] → [2] → [3] → null

--------------------------------------------------------------------------------



## 📚 Regex & String Cleaning Notes (Java)

**Topic:** Removing non-alphanumeric characters using regex in Java

---

### 1️⃣ `replaceAll()` Method

* **Syntax:**

  ```java
  string.replaceAll(regex, replacement)
  ```
* **Purpose:** Replace all substrings matching the regex with the replacement string.
* **Example:**

  ```java
  s.replaceAll("[^a-zA-Z0-9]", "")
  ```

  → Removes all non-alphanumeric characters from `s`.

---

### 2️⃣ Regex Breakdown: `[^a-zA-Z0-9]`

| Part                  | Meaning                                                    |
| --------------------- | ---------------------------------------------------------- |
| `[]`                  | Character class, matches any one character inside brackets |
| `a-z`                 | Any lowercase letter                                       |
| `A-Z`                 | Any uppercase letter                                       |
| `0-9`                 | Any digit                                                  |
| `^` (inside brackets) | Negates the class → matches anything NOT listed            |

✅ So `[^a-zA-Z0-9]` matches **any character that is not a letter or digit** (spaces, punctuation, symbols, etc.)

---

### 3️⃣ Replacement: `""` (Empty String)

* Replaces matched characters with nothing → effectively **removing them**.
* Ensures the string contains **only letters and digits** after this operation.

---

### 4️⃣ Example Walkthrough

```java
String s = "A man, a plan, a canal: Panama!";
s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
System.out.println(s);
```

**Step by step:**

1. Original: `"A man, a plan, a canal: Panama!"`
2. After `replaceAll("[^a-zA-Z0-9]", "")`: `"AmanaplanacanalPanama"`
3. After `.toLowerCase()`: `"amanaplanacanalpanama"`

✅ Now ready for palindrome or anagram checks.

---

### 5️⃣ Key Takeaways

1. **`StringBuilder` is for building/modifying strings**, **not for searching**.
2. **Searching or checking duplicates** → use **HashSet** or **HashMap**.
3. Regex + `replaceAll` is a **fast, clean way to preprocess strings** for algorithms like palindrome checking.
4. After preprocessing, you can use **two pointers, frequency arrays, or sorting** as needed.

---

### 💡 Exam Tip

* Remember: `[^...]` inside brackets **negates** the set.
* Combining with `.toLowerCase()` gives a **uniform string** for comparison.
* Works for **palindrome, anagram, and other character-only string checks**.

General Rule

Every time you divide by 2, the number of steps = how many times 2 fits into n.
That’s exactly the definition of log base 2 of n (log₂(n)).

✅ So:

Time complexity counts steps → steps = log₂(n) → O(log n).

Space complexity counts function calls waiting → also log₂(n) → O(log n).