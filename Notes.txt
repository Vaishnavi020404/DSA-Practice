Reminder(for my self):
150 problem->undertsand hwo to take user input
same for all the problems of linkedlist,stack,queues

| Algorithm      | Best Case  | Worst Case | Average Case | Space Complexity | Stable |
| -------------- | ---------- | ---------- | ------------ | ---------------- | ------ |
| Bubble Sort    | O(n)       | O(nÂ²)      | O(nÂ²)        | O(1)             | Yes    |
| Selection Sort | O(nÂ²)      | O(nÂ²)      | O(nÂ²)        | O(1)             | No     |
| Insertion Sort | O(n)       | O(nÂ²)      | O(nÂ²)        | O(1)             | Yes    |
| Merge Sort     | O(n log n) | O(n log n) | O(n log n)   | O(n)             | Yes    |
| Quick Sort     | O(n log n) | O(nÂ²)      | O(n log n)   | O(log n)         | No     |

âš¡ One-Line Triggers (for quick memory)

Bubble â†’ Neighbors swap, biggest goes right each pass.

Insertion â†’ Like arranging cards, put current element in right place.

Selection â†’ Pick smallest, put in front each time.
===========================================================

Bubble Sort recursive = just replace outer loop with recursion.

Insertion Sort recursive = sort first n-1 elements, then insert last element.

Selection Sort recursive = find min, swap, recurse on rest.
=================================================
ğŸ”¹ Arrays

Better: Simple, fast, contiguous memory, direct index access in O(1).

Not better: Fixed size, insertion/deletion is costly (O(n)).

ğŸ”¹ Sorting

Better: Brings order â†’ faster searching (binary search), easier data analysis.

Not better: Takes time (O(n log n)), not useful if you only need one quick lookup.

ğŸ”¹ Searching

Linear Search: Works on unsorted data, simple to implement, but slow (O(n)).

Binary Search: Super fast (O(log n)) but needs sorted data.

ğŸ”¹ Strings

Better: Easy handling of text data, tons of built-in methods.

Not better: Immutable in Java â†’ every modification creates a new string (memory + time overhead).




ğŸ”¹ Recursion

Why itâ€™s better

Code clarity & simplicity â€“ Problems like tree traversal, graph DFS, backtracking (e.g., N-Queens, permutations), divide-and-conquer (merge sort, quicksort) are naturally recursive. Writing them recursively makes code short, readable, and maps directly to the problem logic.
ğŸ‘‰ Example: DFS in a tree is just â€œvisit node â†’ recurse on childrenâ€ (much cleaner than managing your own stack).

Breaks down complexity â€“ Converts a big problem into smaller subproblems. This is especially useful in dynamic programming and mathematical problems (factorial, Fibonacci, GCD, etc.).

Why itâ€™s not better

Memory overhead â€“ Every recursive call is pushed onto the call stack. If recursion depth is too high, it risks StackOverflowError.
ğŸ‘‰ Example: Recursive Fibonacci (naÃ¯ve) for large n is terrible.

Performance issues â€“ Sometimes iterative solutions are faster and more memory-efficient.
ğŸ‘‰ Example: Factorial with a simple loop avoids extra function call overhead.

Harder to debug â€“ Deep recursion can be confusing to trace in large projects.

Interview-worthy one-liner:

ğŸ‘‰ â€œRecursion makes problems like trees and divide-and-conquer elegant and clean, but itâ€™s memory-hungry and can be slower than iterative approaches for large inputs.â€

ğŸ”¹ HashMap

Better: Stores keyâ€“value pairs with O(1) average lookup, insert, delete, great for quick data access.

Not better: No ordering, uses more memory than arrays/lists.

ğŸ”¹ HashSet

Better: Stores unique elements only with O(1) operations, perfect for duplicate removal and membership checks.

Not better: No ordering, canâ€™t store duplicates, not useful when you need indexed access.

## ğŸ“š Regex & String Cleaning Notes (Java)

**Topic:** Removing non-alphanumeric characters using regex in Java

---

### 1ï¸âƒ£ `replaceAll()` Method

* **Syntax:**

  ```java
  string.replaceAll(regex, replacement)
  ```
* **Purpose:** Replace all substrings matching the regex with the replacement string.
* **Example:**

  ```java
  s.replaceAll("[^a-zA-Z0-9]", "")
  ```

  â†’ Removes all non-alphanumeric characters from `s`.

---

### 2ï¸âƒ£ Regex Breakdown: `[^a-zA-Z0-9]`

| Part                  | Meaning                                                    |
| --------------------- | ---------------------------------------------------------- |
| `[]`                  | Character class, matches any one character inside brackets |
| `a-z`                 | Any lowercase letter                                       |
| `A-Z`                 | Any uppercase letter                                       |
| `0-9`                 | Any digit                                                  |
| `^` (inside brackets) | Negates the class â†’ matches anything NOT listed            |

âœ… So `[^a-zA-Z0-9]` matches **any character that is not a letter or digit** (spaces, punctuation, symbols, etc.)

---

### 3ï¸âƒ£ Replacement: `""` (Empty String)

* Replaces matched characters with nothing â†’ effectively **removing them**.
* Ensures the string contains **only letters and digits** after this operation.

---

### 4ï¸âƒ£ Example Walkthrough

```java
String s = "A man, a plan, a canal: Panama!";
s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
System.out.println(s);
```

**Step by step:**

1. Original: `"A man, a plan, a canal: Panama!"`
2. After `replaceAll("[^a-zA-Z0-9]", "")`: `"AmanaplanacanalPanama"`
3. After `.toLowerCase()`: `"amanaplanacanalpanama"`

âœ… Now ready for palindrome or anagram checks.

---

### 5ï¸âƒ£ Key Takeaways

1. **`StringBuilder` is for building/modifying strings**, **not for searching**.
2. **Searching or checking duplicates** â†’ use **HashSet** or **HashMap**.
3. Regex + `replaceAll` is a **fast, clean way to preprocess strings** for algorithms like palindrome checking.
4. After preprocessing, you can use **two pointers, frequency arrays, or sorting** as needed.

---

### ğŸ’¡ Exam Tip

* Remember: `[^...]` inside brackets **negates** the set.
* Combining with `.toLowerCase()` gives a **uniform string** for comparison.
* Works for **palindrome, anagram, and other character-only string checks**.

General Rule

Every time you divide by 2, the number of steps = how many times 2 fits into n.
Thatâ€™s exactly the definition of log base 2 of n (logâ‚‚(n)).

âœ… So:

Time complexity counts steps â†’ steps = logâ‚‚(n) â†’ O(log n).

Space complexity counts function calls waiting â†’ also logâ‚‚(n) â†’ O(log n).
---------------------------------------------------


When you do:
return head; in a linked list

You arenâ€™t â€œreturning one nodeâ€.
Youâ€™re returning a reference to the first node, which gives access to the entire chain that follows.
head â†’ 10 â†’ 20 â†’ 30 â†’ 40 â†’ null


A linked list is not an array.
A linked list is literally this:

head â†’ [val | next] â†’ [val | next] â†’ [val | next] â†’ null


You donâ€™t store the entire list anywhere.
You only store the address of the first node.
Thatâ€™s your head.

And THAT first node contains a pointer to the second.
The second contains a pointer to the third.
And so on.

So returning head is like saying:

â€œHereâ€™s the address of the first domino â€” push it and the entire chain falls.â€

When you return head, you're actually returning the starting point of the whole chain.

Thatâ€™s all you need.
Thatâ€™s all Java needs.
Thatâ€™s all the universe needs.
--------------------------------------------------
 FIRST: WHAT IS A â€œLIST NAMEâ€ IN LINKED LISTS?

There is no separate thing called a â€œlist name.â€

A linked list is just a chain of nodes, and the word â€œlist1â€ or â€œl1â€ is simply:

 a pointer to the FIRST node in that chain.

Thatâ€™s it.
A â€œlistâ€ is just:

pointer â†’ first node â†’ next â†’ next â†’ next â†’ null


There is no magical list object.
No array-like container.
No list box behind the scenes.

There is ONLY the first node.

So when you say:

ListNode l1;


You are basically saying:

â€œHereâ€™s a variable that will point to the start of some chain of nodes.â€